#include "malwarex.h"
#include <bits/stdc++.h>
using namespace std;

void alice(int N, int M, vector<int> L)
{
	int log2n = 0;
	for (int i = 0; i < 10; i++)
		if ((N - 1) & (1 << i))
			log2n = i;
	log2n++;
	vector<string> vs(log2n, string(N, '0'));
	for (int j = 0; j < N; j++)
		for (int i = 0; i < log2n; i++)
			if (j & (1 << i))
				vs[i][j] = '1';
			else
				vs[i][j] = '0';

	vector<string> receive(log2n);
	for (int i = 0; i < log2n; i++)
		receive[i] = sendMessage(vs[i]);

	vector<bool> fake(N + M);
	int in = 0;
	for (auto a : L)
	{
		for (int j = in; j < in + a; j++)
			fake[j] = 1;
		in += a;
		in++;
	}

	map<int, vector<int>> mivi;
	vector<int> decipher(N + M);
	for (int i = 0; i < N + M; i++)
	{
		int tmp = 0;
		for (int j = log2n - 1; j >= 0; j--)
		{
			tmp *= 2;
			tmp += receive[j][i] - '0';
		}
		if (tmp < N)
		{
			decipher[i] = tmp;
			mivi[tmp].push_back(i);
		}
	}

	vector<int> all;
	for (auto& a : mivi)
		if (a.second.size() == 1)
			all.push_back(a.second.front());

	string last(N, '0');
	while (!mivi.empty())
	{
		auto it = mivi.begin();
		if (it->second.size() != 1)
		{
			int where;
			for (int i = 0; i < it->second.size(); i++)
				if (!fake[it->second[i]])
					where = i;
			for (int i = 0; i < it->second.size(); i++)
				if (i < where)
				{
					last[decipher[all.back()]] = '1';
					all.pop_back();
				}
				else if (i > where)
				{
					last[decipher[all.back()]] = '0';
					all.pop_back();
				}
			all.push_back(it->second[where]);
		}
		mivi.erase(mivi.begin());
	}
	sendMessage(last);
	return;
}

vector<int> bob(int N, int M, int Q, vector<string> S)
{
	int log2n = 0;
	for (int i = 0; i < 10; i++)
		if ((N - 1) & (1 << i))
			log2n = i;
	log2n++;

	map<int, vector<int>> mivi;
	vector<int> decipher(N + M);
	for (int i = 0; i < N + M; i++)
	{
		int tmp = 0;
		for (int j = log2n - 1; j >= 0; j--)
		{
			tmp *= 2;
			tmp += S[j][i] - '0';
		}
		if (tmp < N)
		{
			decipher[i] = tmp;
			mivi[tmp].push_back(i);
		}
	}

	vector<int> all;
	for (auto& a : mivi)
		if (a.second.size() == 1)
			all.push_back(a.second.front());

	vector<bool> vb(N + M);
	while (!mivi.empty())
	{
		auto it = mivi.begin();
		int ct = 0;
		for (int i = 0; i < it->second.size() - 1; i++)
		{
			if (S.back()[all.back()] == '1')
				ct++;
			all.pop_back();
		}
		vb[it->second[ct]] = 1;
		if (it->second.size() > 1)
			all.push_back(it->second[ct]);
		mivi.erase(mivi.begin());
	}

	vector<int> vi;
	int cur = 0;
	for (auto a : vb)
		if (a)
		{
			vi.push_back(cur);
			cur = 0;
		}
		else
			cur++;
	vi.push_back(cur);

	return vi;
}